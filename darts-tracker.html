<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Darts-360 Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    body { font-family: Arial, sans-serif; text-align: center; }
    canvas { 
      border: 0px solid #bbb; 
      position: relative;
    }
    button { margin: 5px; padding: 5px 10px; }
    #calibrationInstructions { margin-top: 10px; font-weight: bold; }
    #shotsLog {
      margin-top: 10px;
      width: 600px;
      margin: 0 auto;
      text-align: left;
      font-size: 14px;
      line-height: 1.4em;
    }
    
    /* Canvas container for positioning the icons */
    #canvasContainer {
      position: relative;
      width: 600px;
      height: 600px;
      margin: 0 auto;
    }
    
    /* Main flex container for dartboard and stats panel */
    #dartboardContainer {
      display: flex;
      justify-content: center;
      gap: 20px;
      max-width: 900px;
      margin: 0 auto;
    }
    
    /* Stats panel styling */
    #statsPanel {
      width: 250px;
      height: 600px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      border-radius: 8px;
      overflow: hidden;
      background: white;
      display: flex;
      flex-direction: column;
    }
    
    #statsHeader {
      background: #444444;
      color: white;
      padding: 10px;
      font-weight: bold;
      text-align: center;
    }
    
    #statsContent {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
    }
    
    #deviationMap {
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    
    #statsSummary {
      font-size: 13px;
      text-align: left;
      padding: 10px;
      background: #f7f7f7;
      border-radius: 4px;
    }
    
    .stat-row {
      margin-bottom: 5px;
      display: flex;
      justify-content: space-between;
    }
    
    .stat-label {
      font-weight: bold;
    }
    
    /* Icon button styling */
    .icon-button {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
      border: none;
    }
    .icon-button:hover {
      background: rgba(255, 255, 255, 1);
      transform: scale(1.1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.3);
    }
    .icon-button:active {
      transform: scale(0.95);
    }
    .icon-button i {
      font-size: 20px;
      color: #333;
    }
    .icon-tooltip {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      white-space: nowrap;
    }
    .icon-button:hover .icon-tooltip {
      opacity: 1;
    }
    
    /* Positioning tooltips based on button location */
    #importDataBtn .icon-tooltip, #exportDataBtn .icon-tooltip {
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 5px;
    }
    
    #clearDataBtn .icon-tooltip {
      top: 100%;
      right: 0;
      margin-top: 5px;
    }
    
    #uploadPhotoBtn .icon-tooltip {
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 5px;
    }
    
    #quickCalibBtn .icon-tooltip, #fullCalibBtn .icon-tooltip {
      bottom: 100%;
      right: 0;
      margin-bottom: 5px;
    }
    
    /* Positioning as requested */
    #importDataBtn { top: 10px; left: 10px; }
    #exportDataBtn { top: 10px; left: 60px; }
    #undoBtn { top: 10px; right: 110px; }
    #redoBtn { top: 10px; right: 60px; }
    #clearDataBtn { top: 10px; right: 10px; }
    #uploadPhotoBtn { bottom: 10px; left: 10px; }
    #quickCalibBtn { bottom: 10px; right: 10px; }
    #fullCalibBtn { bottom: 10px; right: 60px; }
    
    /* Custom notification */
    #notification {
      position: absolute;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 100;
      text-align: center;
      max-width: 80%;
      pointer-events: none; /* Allow clicks to pass through */
      display: flex;
      align-items: center;
      justify-content: flex-start;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    #notification.success {
      background-color: rgba(232, 245, 233, 0.85);
      border-left: 4px solid #4CAF50;
      color: #333;
    }
    
    #notification.error {
      background-color: rgba(255, 235, 238, 0.85);
      border-left: 4px solid #F44336;
      color: #333;
    }
    
    #notification.info {
      background-color: rgba(227, 242, 253, 0.85);
      border-left: 4px solid #2196F3;
      color: #333;
    }
    
    #notification i {
      margin-right: 10px;
      font-size: 16px;
    }
    
    #notification.success i {
      color: #4CAF50;
    }
    
    #notification.error i {
      color: #F44336;
    }
    
    #notification.info i {
      color: #2196F3;
    }
    
    /* Custom confirmation dialog */
    #confirmDialog {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
      text-align: center;
      min-width: 250px;
    }
    #confirmMessage {
      margin-bottom: 15px;
      font-size: 16px;
    }
    .dialog-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .dialog-button {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.2s;
    }
    #confirmOk {
      background: #444444;
      color: white;
    }
    #confirmCancel {
      background: #f0f0f0;
      color: #333;
    }
    #confirmOk:hover {
      background: #333333;
    }
    #confirmCancel:hover {
      background: #e0e0e0;
    }
    
    /* Magnifier styling */
    #magnifier {
      position: absolute;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      border: 2px solid #333;
      box-shadow: 0 3px 10px rgba(0,0,0,0.3);
      pointer-events: none; /* Let events pass through to canvas */
      z-index: 100;
      background-color: white;
      overflow: hidden;
      display: none; /* Hidden by default */
    }
    
    #magnifierCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <h1>Darts Tracker v0.1.2</h1>
  <div id="dartboardContainer">
    <div id="canvasContainer">
      <canvas id="dartboard" width="600" height="600"></canvas>
      <button id="importDataBtn" class="icon-button" title="Import Data">
        <i class="fas fa-file-import"></i>
        <span class="icon-tooltip">Import Data</span>
      </button>
      <button id="exportDataBtn" class="icon-button" title="Export Data">
        <i class="fas fa-file-export"></i>
        <span class="icon-tooltip">Export Data</span>
      </button>
      <button id="undoBtn" class="icon-button" title="Undo">
        <i class="fas fa-undo-alt"></i>
        <span class="icon-tooltip">Undo</span>
      </button>
      <button id="redoBtn" class="icon-button" title="Redo">
        <i class="fas fa-redo-alt"></i>
        <span class="icon-tooltip">Redo</span>
      </button>
      <button id="clearDataBtn" class="icon-button" title="Clear Shots">
        <i class="fas fa-trash-alt"></i>
        <span class="icon-tooltip">Clear Shots</span>
      </button>
      <button id="uploadPhotoBtn" class="icon-button" title="Upload Photo">
        <i class="fas fa-image"></i>
        <span class="icon-tooltip">Upload Board Photo</span>
      </button>
      <button id="quickCalibBtn" class="icon-button" title="Quick Calibration">
        <i class="fas fa-bolt"></i>
        <span class="icon-tooltip">Quick Calibration</span>
      </button>
      <button id="fullCalibBtn" class="icon-button" title="Full Calibration">
        <i class="fas fa-bullseye"></i>
        <span class="icon-tooltip">Full Calibration</span>
      </button>
      <div id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notification-message"></span>
      </div>
      <div id="confirmDialog">
        <div id="confirmMessage"></div>
        <div class="dialog-buttons">
          <button id="confirmOk" class="dialog-button">OK</button>
          <button id="confirmCancel" class="dialog-button">Cancel</button>
        </div>
      </div>
      <div id="magnifier">
        <canvas id="magnifierCanvas" width="120" height="120"></canvas>
      </div>
    </div>
    
    <!-- New Statistics Panel -->
    <div id="statsPanel">
      <div id="statsHeader">Throw Accuracy Statistics</div>
      <div id="statsContent">
        <canvas id="deviationMap" width="230" height="230"></canvas>
        <div id="statsSummary">
          <div class="stat-row">
            <span class="stat-label">Average Deviation:</span>
            <span id="avgDeviation">-</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Maximum Deviation:</span>
            <span id="maxDeviation">-</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Horizontal Tendency:</span>
            <span id="horizontalTendency">-</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Vertical Tendency:</span>
            <span id="verticalTendency">-</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">Total Throws Analyzed:</span>
            <span id="totalThrows">0</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="calibrationInstructions"></div>
  <div id="shotsLog"></div>

  <!-- Hidden file inputs for .drts file and board photo -->
  <input type="file" id="fileInput" accept=".drts" style="display:none;" />
  <input type="file" id="photoInput" accept="image/*" style="display:none;" />

  <script>
    /*****************************************
     *       CONSTANTS & DEFAULTS
     *****************************************/
    const canvas = document.getElementById("dartboard");
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Default ring radii (in pixels) for a 600×600 board.
    let defaultBullseyeRadius   = 15;
    let defaultOuterBullRadius  = 30;
    let defaultTripleRingInner  = 120;
    let defaultTripleRingOuter  = 140;
    let defaultDoubleRingInner  = 240;
    let defaultDoubleRingOuter  = 260;

    // Official dartboard diameter in mm.
    const realBoardDiameterMM = 451;
    // For quick calibration, official ring distances (mm)
    const OFFICIAL_MM = {
      bullseye:   6.35,
      outerBull:  15.9,
      tripleIn:   99,
      tripleOut:  107,
      doubleIn:   162,
      doubleOut:  170
    };

    const sectorAngle = Math.PI / 10;  // 18° per sector.
    const sectorOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

    /*****************************************
     *        CALIBRATION DATA
     *****************************************/
    let calibration = {
      mode: "none", // "none", "full", or "quick"
      center: { x: centerX, y: centerY },
      bullseye: defaultBullseyeRadius,
      outerBull: defaultOuterBullRadius,
      tripleIn: defaultTripleRingInner,
      tripleOut: defaultTripleRingOuter,
      doubleIn: defaultDoubleRingInner,
      doubleOut: defaultDoubleRingOuter,
      rotation: -Math.PI / 20,
      photoDataUrl: null
    };

    /*****************************************
     *          SHOT DATA & AIM
     *****************************************/
    let shots = [];  // Each shot: { aim: {x,y}, hit: {x,y} }
    let undoStack = []; // Store removed shots for redo
    let currentAim = null;

    /*****************************************
     *        BOARD IMAGE & LOG
     *****************************************/
    const boardImage = new Image();
    boardImage.src = "board.png";
    const shotsLogDiv = document.getElementById("shotsLog");

    /*****************************************
     *        CALIBRATION STATE
     *****************************************/
    let isCalibrating = false;
    let calibrationStep = 0;  // For "full": 1..8, for "quick": 1..2.
    let calibMousePos = null;   // Live mouse position during calibration.

    /*****************************************
     *       LOAD & SAVE FUNCTIONS
     *****************************************/
    function loadShots() {
      const stored = localStorage.getItem("dartDataAll");
      if (stored) {
        try {
          let parsed = JSON.parse(stored);
          if (parsed.shots && Array.isArray(parsed.shots)) { 
            shots = parsed.shots; 
          } else {
            shots = []; // Ensure shots is initialized as empty array if invalid
            currentAim = null;
          }
          if (parsed.calibration) { 
            calibration = parsed.calibration; 
            applyCalibration(); 
          }
          if (parsed.currentAim) {
            currentAim = parsed.currentAim;
          }
        } catch (e) {
          console.error("Error loading shots:", e);
          shots = [];
          currentAim = null;
        }
      } else {
        shots = [];
        currentAim = null;
      }
    }
    function saveShots() {
      let dataObj = { 
        shots, 
        calibration,
        currentAim  // Save the current aim position
      };
      localStorage.setItem("dartDataAll", JSON.stringify(dataObj));
    }

    /*****************************************
     *            CLEAR DATA
     *****************************************/
    // Clear only shot data (leaving calibration intact)
    document.getElementById("clearDataBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to clear all shots? Calibration will be retained.", function() {
        shots = [];
        undoStack = []; // Clear the undo stack when adding a new shot after undoing
        shotsLogDiv.innerHTML = "";
        currentAim = null;
        resetFadingDarts(); // Reset animations when clearing shots
        saveShots();
        drawAll();
        showNotification("Shots cleared successfully", "success");
      });
    });

    /*****************************************
     *           APPLY CALIBRATION
     *****************************************/
    function applyCalibration() {
      if (calibration.photoDataUrl) {
        let tmpImg = new Image();
        tmpImg.src = calibration.photoDataUrl;
        tmpImg.onload = function() {
          boardImage.src = tmpImg.src;
          drawAll();
        };
      }
      drawAll();
    }

    /*****************************************
     *         UTILITY FUNCTIONS
     *****************************************/
    // Convert pixels to centimeters based on the calibrated double ring.
    function pxToCM(pxDist) {
      let boardDiameterPX = calibration.doubleOut * 2;
      let mmPerPx = realBoardDiameterMM / boardDiameterPX;
      return (pxDist * mmPerPx) / 10;
    }

    /*****************************************
     *              SCORING
     *****************************************/
    function getDartScore(x, y) {
      const dx = x - calibration.center.x;
      const dy = y - calibration.center.y;
      const r = Math.hypot(dx, dy);
      if (r > calibration.doubleOut) return 0;
      if (r <= calibration.bullseye) return 50;
      if (r <= calibration.outerBull) return 25;
      let multiplier = 1;
      if (r >= calibration.tripleIn && r <= calibration.tripleOut) multiplier = 3;
      else if (r >= calibration.doubleIn && r <= calibration.doubleOut) multiplier = 2;
      let angle = Math.atan2(dy, dx);
      let normalized = (angle + Math.PI/2 - calibration.rotation + sectorAngle + 2*Math.PI) % (2*Math.PI);
      let sectorIndex = Math.floor(normalized / sectorAngle);
      let baseValue = sectorOrder[sectorIndex];
      return baseValue * multiplier;
    }

    /*****************************************
     *          DRAWING FUNCTIONS
     *****************************************/
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(boardImage, 0, 0, canvas.width, canvas.height);
      
      // Draw grid wiring: ring boundaries & radial lines.
      ctx.save();
      ctx.globalAlpha = 0.8;
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = "gray";
      let rings = [
        calibration.bullseye,
        calibration.outerBull,
        calibration.tripleIn,
        calibration.tripleOut,
        calibration.doubleIn,
        calibration.doubleOut
      ];
      rings.forEach(r => {
        ctx.beginPath();
        ctx.arc(calibration.center.x, calibration.center.y, r, 0, 2*Math.PI);
        ctx.stroke();
      });
      for (let i = 0; i < 20; i++) {
        let angle = calibration.rotation - Math.PI/2 + i * sectorAngle;
        let x1 = calibration.center.x + calibration.bullseye * Math.cos(angle);
        let y1 = calibration.center.y + calibration.bullseye * Math.sin(angle);
        let x2 = calibration.center.x + calibration.doubleOut * Math.cos(angle);
        let y2 = calibration.center.y + calibration.doubleOut * Math.sin(angle);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      // In calibration mode, re-add custom cursor and preview.
      if (isCalibrating && calibMousePos) {
        ctx.save();
        
        // For bullseye click (step 1), add horizontal and vertical crosshair lines
        if ((calibration.mode === "full" && calibrationStep === 1) || 
            (calibration.mode === "quick" && calibrationStep === 1)) {
          ctx.setLineDash([5, 5]);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1;
          
          // Horizontal line
          ctx.beginPath();
          ctx.moveTo(0, calibMousePos.y);
          ctx.lineTo(canvas.width, calibMousePos.y);
          ctx.stroke();
          
          // Vertical line
          ctx.beginPath();
          ctx.moveTo(calibMousePos.x, 0);
          ctx.lineTo(calibMousePos.x, canvas.height);
          ctx.stroke();
        }
        
        // If in ring calibration steps (for full: steps 2–7), draw dashed preview circle.
        if (
          (calibration.mode==="full" && calibrationStep >= 2 && calibrationStep <= 7)
        ) {
          ctx.setLineDash([5, 5]);
          let rPrev = Math.hypot(calibMousePos.x - calibration.center.x, calibMousePos.y - calibration.center.y);
          ctx.beginPath();
          ctx.arc(calibration.center.x, calibration.center.y, rPrev, 0, 2*Math.PI);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        
        // For final rotation step (full step 8 or quick step 2)
        if (
          (calibration.mode==="full" && calibrationStep===8) ||
          (calibration.mode==="quick" && calibrationStep===2)
        ) {
          const dx = calibMousePos.x - calibration.center.x;
          const dy = calibMousePos.y - calibration.center.y;
          const r = Math.hypot(dx, dy);
          const angle = Math.atan2(dy, dx);
          
          // Line from center to cursor
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(calibration.center.x, calibration.center.y);
          ctx.lineTo(calibMousePos.x, calibMousePos.y);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Line 18 degrees to the left (to indicate sector 20)
          const leftAngle = angle - (Math.PI / 10); // 18 degrees = PI/10 radians
          const leftLineX = calibration.center.x + r * Math.cos(leftAngle);
          const leftLineY = calibration.center.y + r * Math.sin(leftAngle);
          
          ctx.beginPath();
          ctx.moveTo(calibration.center.x, calibration.center.y);
          ctx.lineTo(leftLineX, leftLineY);
          ctx.stroke();
          
          // Arc spanning 18 degrees from cursor to the left
          ctx.beginPath();
          ctx.arc(calibration.center.x, calibration.center.y, r, angle, leftAngle, true);
          ctx.stroke();
        }
        
        // Draw the custom calibration cursor: a white circle with a plus (cross) inside.
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(calibMousePos.x, calibMousePos.y, 5, 0, 2*Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(calibMousePos.x - 3, calibMousePos.y);
        ctx.lineTo(calibMousePos.x + 3, calibMousePos.y);
        ctx.moveTo(calibMousePos.x, calibMousePos.y - 3);
        ctx.lineTo(calibMousePos.x, calibMousePos.y + 3);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    }

    // Highlight the aimed field:
    // If aiming within bull (r ≤ outerBull), fill full circle; otherwise fill the annular sector.
    function highlightAimedField(aimPos) {
      if (!aimPos) return;
      const dx = aimPos.x - calibration.center.x;
      const dy = aimPos.y - calibration.center.y;
      const r = Math.hypot(dx, dy);
      if (r <= calibration.outerBull) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(calibration.center.x, calibration.center.y, calibration.outerBull, 0, 2*Math.PI);
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.fill();
        ctx.restore();
        return;
      }
      let ringMin = 0, ringMax = 0;
      if (r <= calibration.tripleIn) {
        ringMin = calibration.outerBull;
        ringMax = calibration.tripleIn;
      } else if (r <= calibration.tripleOut) {
        ringMin = calibration.tripleIn;
        ringMax = calibration.tripleOut;
      } else if (r <= calibration.doubleIn) {
        ringMin = calibration.tripleOut;
        ringMax = calibration.doubleIn;
      } else if (r <= calibration.doubleOut) {
        ringMin = calibration.doubleIn;
        ringMax = calibration.doubleOut;
      } else { return; }
      let angle = Math.atan2(dy, dx);
      let normalized = (angle + Math.PI/2 - calibration.rotation + 2*Math.PI) % (2*Math.PI);
      let sectorIdx = Math.floor(normalized / sectorAngle);
      let sectorStart = sectorIdx * sectorAngle;
      let sectorEnd = sectorStart + sectorAngle;
      let startAngle = sectorStart - Math.PI/2 + calibration.rotation;
      let endAngle = sectorEnd - Math.PI/2 + calibration.rotation;
      ctx.save();
      ctx.beginPath();
      ctx.arc(calibration.center.x, calibration.center.y, ringMax, startAngle, endAngle, false);
      ctx.arc(calibration.center.x, calibration.center.y, ringMin, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
      ctx.fill();
      ctx.restore();
    }

    function drawShots() {
      highlightAimedField(currentAim);
      
      // First, draw the standard darts
      shots.slice().reverse().forEach((shot, reversedIdx) => {
        const idx = shots.length - 1 - reversedIdx; // Get original index
        
        // Calculate which darts should be fully visible
        // This is based on the remainder when dividing total shots by 3
        let currentTurnDartCount = shots.length % 3;
        if (currentTurnDartCount === 0) currentTurnDartCount = 3; // If it's a complete turn
        
        // Check if this dart should be displayed
        // We keep the current turn (1-3 darts) plus exactly 12 more darts
        const maxTransparentDarts = 12;
        if (reversedIdx >= currentTurnDartCount + maxTransparentDarts) return;
        
        // Check if this dart is currently being animated
        if (fadingDarts.some(fd => fd.dartIndex === idx)) {
          // Skip - will be drawn in the fading darts section
          return; 
        }
        
        // Only the last 1-3 darts of the current turn should be fully opaque
        const isCurrentTurnDart = reversedIdx < currentTurnDartCount;
        const opacity = isCurrentTurnDart ? FULL_OPACITY : REDUCED_OPACITY;
        
        // Use our helper function to draw the dart
        drawDartAtOpacity(shot, opacity);
      });
      
      // Then, draw any fading darts
      fadingDarts.forEach(fadingDart => {
        if (fadingDart.dartIndex >= 0 && fadingDart.dartIndex < shots.length) {
          // Get the shot data from the main array
          const shot = shots[fadingDart.dartIndex];
          // Draw with the current animation opacity
          drawDartAtOpacity(shot, fadingDart.opacity);
        }
      });
    }

    function drawAll() {
      if (!boardImage.complete) return;
      drawBoard();
      drawShots();
    }

    /*****************************************
     *        CALIBRATION HANDLERS
     *****************************************/
    function updateInstructions() {
      // Clear any existing text in the instructions div
      const instr = document.getElementById("calibrationInstructions");
      instr.textContent = "";
      
      if (!isCalibrating) return;
      
      let msg = "";
      if (calibration.mode === "full") {
        switch (calibrationStep) {
          case 1: msg = "Step 1/8: Select the middle of the board"; break;
          case 2: msg = "Step 2/8: Select bullseye ring"; break;
          case 3: msg = "Step 3/8: Select outer bull ring"; break;
          case 4: msg = "Step 4/8: Select inner treble ring"; break;
          case 5: msg = "Step 5/8: Select outer treble ring"; break;
          case 6: msg = "Step 6/8: Select inner double ring"; break;
          case 7: msg = "Step 7/8: Select outer double ring"; break;
          case 8: msg = "Step 8/8: Select sector 20"; break;
        }
      } else if (calibration.mode === "quick") {
        if (calibrationStep === 1) msg = "Step 1/2: Select the middle of the board";
        else if (calibrationStep === 2) msg = "Step 2/2: Select sector 20";
      }
      
      // Show the message as a persistent notification
      showNotification(msg, "info", 0, true);
    }

    function distFromCenter(pt) {
      return Math.hypot(pt.x - calibration.center.x, pt.y - calibration.center.y);
    }

    function handleFullCalibrationClick(pt) {
      switch (calibrationStep) {
        case 1: calibration.center = pt; break;
        case 2: calibration.bullseye = distFromCenter(pt); break;
        case 3: calibration.outerBull = distFromCenter(pt); break;
        case 4: calibration.tripleIn = distFromCenter(pt); break;
        case 5: calibration.tripleOut = distFromCenter(pt); break;
        case 6: calibration.doubleIn = distFromCenter(pt); break;
        case 7: calibration.doubleOut = distFromCenter(pt); break;
        case 8:
          let dx = pt.x - calibration.center.x;
          let dy = pt.y - calibration.center.y;
          let angle = Math.atan2(dy, dx);
          calibration.rotation = angle + Math.PI / 2;
          
          // Complete calibration, completely reset all calibration-related state
          isCalibrating = false;
          calibrationStep = 0;
          calibMousePos = null;
          
          // Redraw without calibration overlays
          drawAll();
          
          // Use regular notification for completion
          clearNotification(); 
          showNotification("Full calibration complete", "success");// Reset notification state
          return; // Skip showing next notification
      }
      
      // Show success message and advance step
      if (calibrationStep < 8) {
        calibrationStep++;
        updateInstructions();
      }
      
      drawAll();
      saveShots();
    }

    function handleQuickCalibrationClick(pt) {
      if (calibrationStep === 1) { calibration.center = pt; }
      else if (calibrationStep === 2) {
        let dx = pt.x - calibration.center.x;
        let dy = pt.y - calibration.center.y;
        let distPx = Math.hypot(dx, dy);
        let pxPerMm = distPx / OFFICIAL_MM.doubleOut;
        calibration.bullseye = OFFICIAL_MM.bullseye * pxPerMm;
        calibration.outerBull = OFFICIAL_MM.outerBull * pxPerMm;
        calibration.tripleIn = OFFICIAL_MM.tripleIn * pxPerMm;
        calibration.tripleOut = OFFICIAL_MM.tripleOut * pxPerMm;
        calibration.doubleIn = OFFICIAL_MM.doubleIn * pxPerMm;
        calibration.doubleOut = OFFICIAL_MM.doubleOut * pxPerMm;
        let angle = Math.atan2(dy, dx);
        calibration.rotation = angle + Math.PI / 2;
        
        // Complete calibration, completely reset all calibration-related state
        isCalibrating = false;
        calibrationStep = 0;
        calibMousePos = null;
        
        // Redraw without calibration overlays
        drawAll();
        
        // Use regular notification for completion
        clearNotification(); // Reset notification state
        showNotification("Quick calibration complete", "success");
        return; // Skip showing next notification
      }
      
      // Show success message and advance step
      if (calibrationStep < 2) {
        calibrationStep++;
        updateInstructions();
      }
      
      drawAll();
      saveShots();
    }

    canvas.addEventListener("mousemove", function(e) {
      if (!isCalibrating) return;
      let rect = canvas.getBoundingClientRect();
      calibMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      drawAll();
    });

    canvas.addEventListener("click", function(e) {
      let rect = canvas.getBoundingClientRect();
      let clickPt = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      if (isCalibrating) {
        if (calibration.mode === "full") {
          handleFullCalibrationClick(clickPt);
        } else if (calibration.mode === "quick") {
          handleQuickCalibrationClick(clickPt);
        }
      } else {
        if (!currentAim) {
          showNotification("Right-click first to set your aim", "error");
          return;
        }
        let hitPt = { x: clickPt.x, y: clickPt.y };
        
        // Store previous shot count to check for animations
        const prevShotCount = shots.length;
        
        // Add the new shot
        shots.push({ aim: currentAim, hit: hitPt });
        undoStack = []; // Clear the undo stack when adding a new shot after undoing
        saveShots();
        
        // Update UI and check for animations
        updateShotLog();
        checkForFadingDarts(); // Check if any darts need to be animated
        
        // Draw everything
        drawAll();
        updateUndoRedoState();
        
        // Reset magnifier to offset position after click
        isMouseDown = false;
        let x = e.clientX - rect.left;
        let y = e.clientY - rect.top;
        updateMagnifier(x, y, false);
      }
    });

    // --- Right-Click Aiming Mechanism ---
    canvas.addEventListener("contextmenu", function(e) {
      e.preventDefault();
      if (isCalibrating) return;  // Do not set aim during calibration.
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      let pos = getSnappedPosition(x, y);
      if (!pos) {
        showNotification("Aim must be within the board", "error");
        return;
      }
      currentAim = pos;
      drawAll();
    });

    function getSnappedPosition(px, py) {
      let dx = px - calibration.center.x;
      let dy = py - calibration.center.y;
      let r = Math.hypot(dx, dy);
      // For bull area, if within outerBull, snap aim to board center.
      if (r <= calibration.outerBull) {
        return { x: calibration.center.x, y: calibration.center.y };
      }
      let regionCenter = null;
      if (r <= calibration.tripleIn) {
        regionCenter = (calibration.outerBull + calibration.tripleIn) / 2;
      } else if (r <= calibration.tripleOut) {
        regionCenter = (calibration.tripleIn + calibration.tripleOut) / 2;
      } else if (r <= calibration.doubleIn) {
        regionCenter = (calibration.tripleOut + calibration.doubleIn) / 2;
      } else if (r <= calibration.doubleOut) {
        regionCenter = (calibration.doubleIn + calibration.doubleOut) / 2;
      } else { return null; }
      let theta = Math.atan2(dy, dx);
      let normalized = (theta + Math.PI/2 - calibration.rotation + 2*Math.PI) % (2*Math.PI);
      let sectorIdx = Math.floor(normalized / sectorAngle);
      let snappedAngle = (sectorIdx + 0.5) * sectorAngle - Math.PI/2 + calibration.rotation;
      return {
        x: calibration.center.x + regionCenter * Math.cos(snappedAngle),
        y: calibration.center.y + regionCenter * Math.sin(snappedAngle)
      };
    }

    /*****************************************
     *            BUTTON HANDLERS
     *****************************************/
    document.getElementById("exportDataBtn").addEventListener("click", function() {
      let dataObj = { shots, calibration };
      if (!calibration.photoDataUrl) {
        try {
          let tempCanvas = document.createElement("canvas");
          tempCanvas.width = boardImage.width;
          tempCanvas.height = boardImage.height;
          let tmpCtx = tempCanvas.getContext("2d");
          tmpCtx.drawImage(boardImage, 0, 0);
          calibration.photoDataUrl = tempCanvas.toDataURL("image/png");
        } catch(e) { console.warn("Could not encode board image:", e); }
      }
      dataObj.calibration = calibration;
      let dataStr = JSON.stringify(dataObj);
      let blob = new Blob([dataStr], { type: "text/plain" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "dartdata.drts";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      showNotification("Data exported successfully", "success");
    });

    document.getElementById("importDataBtn").addEventListener("click", function() {
      document.getElementById("fileInput").click();
    });
    document.getElementById("fileInput").addEventListener("change", function(e) {
      let file = e.target.files[0];
      if (!file) return;
      if (!file.name.endsWith(".drts")) {
        showNotification("Please select a .drts file", "error");
        return;
      }
      let reader = new FileReader();
      reader.onload = function(event) {
        try {
          let imported = JSON.parse(event.target.result);
          if (!imported.shots || !imported.calibration) {
            showNotification("Invalid file format", "error");
            return;
          }
          shots = imported.shots;
          calibration = imported.calibration;
          applyCalibration();
          saveShots();
          shotsLogDiv.innerHTML = "";
          drawAll();
          showNotification("Imported shots and calibration", "success");
        } catch(err) {
          showNotification("Error reading file: " + err, "error");
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("uploadPhotoBtn").addEventListener("click", function() {
      document.getElementById("photoInput").click();
    });
    document.getElementById("photoInput").addEventListener("change", function(e) {
      let file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = function(evt) {
        calibration.photoDataUrl = evt.target.result;
        boardImage.src = evt.target.result;
        boardImage.onload = function() {
          drawAll();
          showNotification("Board image updated successfully", "success");
        };
        saveShots();
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("fullCalibBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to re-calibrate?", function() {
        calibration.mode = "full";
        isCalibrating = true;
        calibrationStep = 1;
        calibMousePos = null;
        updateInstructions();
        drawAll();
      });
    });

    document.getElementById("quickCalibBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to re-calibrate?", function() {
        calibration.mode = "quick";
        isCalibrating = true;
        calibrationStep = 1;
        calibMousePos = null;
        updateInstructions();
        drawAll();
      });
    });

    /*****************************************
     *            ANIMATION SYSTEM
     *****************************************/
    // Animation state variables
    let fadingDarts = []; // Array to track darts that are currently being animated
    let lastShotCount = 0; // Remember previous shot count for detecting changes
    
    // Animation constants
    const ANIMATION_DURATION = 500; // Duration in milliseconds
    const FULL_OPACITY = 1.0;
    const REDUCED_OPACITY = 0.25;

    /*****************************************
     *            UNDO-REDO SYSTEM
     *****************************************/
    function updateUndoRedoState() {
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      
      // Disable undo button if no shots to undo
      if (shots.length === 0) {
        undoBtn.disabled = true;
        undoBtn.style.opacity = 0.5;
        undoBtn.style.cursor = "not-allowed";
      } else {
        undoBtn.disabled = false;
        undoBtn.style.opacity = 1;
        undoBtn.style.cursor = "pointer";
      }
      
      // Disable redo button if no shots to redo
      if (undoStack.length === 0) {
        redoBtn.disabled = true;
        redoBtn.style.opacity = 0.5;
        redoBtn.style.cursor = "not-allowed";
      } else {
        redoBtn.disabled = false;
        redoBtn.style.opacity = 1;
        redoBtn.style.cursor = "pointer";
      }
    }
    
    // Helper function to update shot log display
    function updateShotLog() {
      shotsLogDiv.innerHTML = "";
      
      // Display all shots with recent ones highlighted
      shots.forEach((shot, idx) => {
        const reversedIdx = shots.length - 1 - idx;
        
        // Calculate which darts should be fully visible
        // This is based on the remainder when dividing total shots by 3
        let currentTurnDartCount = shots.length % 3 || 3; // 1-3 darts in current turn
        
        let dx = shot.hit.x - shot.aim.x;
        let dy = shot.hit.y - shot.aim.y;
        let distCm = Math.hypot(pxToCM(dx), pxToCM(dy));
        let score = getDartScore(shot.hit.x, shot.hit.y);
        
        // Only the last 1-3 darts of the current turn should be highlighted
        const isCurrentTurnDart = reversedIdx < currentTurnDartCount;
        
        // Apply different styling based on turn
        let shotStyle = "";
        if (isCurrentTurnDart) {
          // Current turn darts - bold
          shotStyle = "font-weight: bold;";
        } else if (reversedIdx < currentTurnDartCount + 12) {
          // Previous turns (up to 12 darts beyond current turn) - dimmed
          shotStyle = "opacity: 0.6;";
        } else {
          // Older shots - very dimmed
          shotStyle = "opacity: 0.25;";
        }
        
        shotsLogDiv.innerHTML += `<div style="${shotStyle}">Shot #${idx+1}: Score=${score}, Distance=${distCm.toFixed(2)} cm</div>`;
      });
    }

    // Reset any ongoing animations (for undo/redo operations)
    function resetFadingDarts() {
      fadingDarts = [];
      lastShotCount = shots.length;
    }

    document.getElementById("undoBtn").addEventListener("click", function() {
      if (shots.length === 0) return;
      undoStack.push(shots.pop());
      updateShotLog();
      saveShots();
      resetFadingDarts(); // Reset animations when undoing
      drawAll();
      updateUndoRedoState();
      showNotification("Last shot undone", "success");
    });

    document.getElementById("redoBtn").addEventListener("click", function() {
      if (undoStack.length === 0) return;
      shots.push(undoStack.pop());
      updateShotLog();
      saveShots();
      resetFadingDarts(); // Reset animations when redoing
      drawAll();
      updateUndoRedoState();
      showNotification("Shot redone", "success");
    });

    /*****************************************
     *            NOTIFICATION SYSTEM
     *****************************************/
    /**
     * Show a notification with specified type
     * @param {string} message - The message to display
     * @param {string} type - Either 'success', 'error', or 'info'
     * @param {number} duration - How long to display the notification (ms), or 0 for persistent
     * @param {boolean} persistent - If true, notification stays until clicked
     */
    function showNotification(message, type = 'success', duration = 3000, persistent = false) {
      const notification = document.getElementById("notification");
      const notificationMessage = document.getElementById("notification-message");
      
      // Set message
      notificationMessage.textContent = message;
      
      // Set notification type
      notification.className = type; // Reset classes and set type
      
      // Update icon based on type
      const iconElement = notification.querySelector('i');
      if (type === 'success') {
        iconElement.className = 'fas fa-check-circle';
      } else if (type === 'error') {
        iconElement.className = 'fas fa-exclamation-circle';
      } else if (type === 'info') {
        iconElement.className = 'fas fa-info-circle';
      }
      
      // Show notification
      notification.style.opacity = 1;
      
      // For persistent notifications, add click handler to dismiss
      if (persistent) {
        // Make it accessible to clicks (remove pointer-events: none)
        notification.style.pointerEvents = 'auto';
        notification.style.cursor = 'pointer';
        
        // One-time click handler to dismiss
        notification.onclick = function() {
          notification.style.opacity = 0;
          notification.style.pointerEvents = 'none';
          notification.style.cursor = 'default';
          notification.onclick = null;
          
          // If we're in calibration mode, advance to the next step
          if (isCalibrating) {
            if (calibration.mode === "full") {
              handleFullCalibrationClick({ x: calibration.center.x, y: calibration.center.y });
            } else if (calibration.mode === "quick") {
              handleQuickCalibrationClick({ x: calibration.center.x, y: calibration.center.y });
            }
          }
        };
      } else {
        // Reset click handler and style
        notification.style.pointerEvents = 'none';
        notification.style.cursor = 'default';
        notification.onclick = null;
        
        // Automatically hide the notification after the specified duration
        if (duration > 0) {
          setTimeout(() => {
            notification.style.opacity = 0;
          }, duration);
        }
      }
    }
    
    // Helper function to clear notification state
    function clearNotification() {
      const notification = document.getElementById("notification");
      notification.style.opacity = 0;
      notification.style.pointerEvents = 'none';
      notification.style.cursor = 'default';
      notification.onclick = null;
    }

    function showConfirmDialog(message, onConfirm) {
      const dialog = document.getElementById("confirmDialog");
      const messageEl = document.getElementById("confirmMessage");
      const okButton = document.getElementById("confirmOk");
      const cancelButton = document.getElementById("confirmCancel");
      
      messageEl.textContent = message;
      dialog.style.display = "block";
      
      // Set up the button handlers
      okButton.onclick = function() {
        dialog.style.display = "none";
        onConfirm();
      };
      
      cancelButton.onclick = function() {
        dialog.style.display = "none";
      };
    }

    /*****************************************
     *              INIT
     *****************************************/
    function init() {
      // Load all stored data
      const stored = localStorage.getItem("dartDataAll");
      if (stored) {
        try {
          let parsed = JSON.parse(stored);
          
          // Load shots
          if (parsed.shots && Array.isArray(parsed.shots)) { 
            shots = parsed.shots; 
          } else {
            shots = []; 
          }
          
          // Load calibration
          if (parsed.calibration) { 
            calibration = parsed.calibration; 
            applyCalibration(); 
          }
          
          // Load aim
          if (parsed.currentAim) {
            currentAim = parsed.currentAim;
          }
        } catch (e) {
          console.error("Error loading data:", e);
          shots = [];
          currentAim = null;
        }
      } else {
        shots = [];
        currentAim = null;
      }
      
      // Reset undo/redo stack and animations
      undoStack = [];
      fadingDarts = [];
      
      // Update shot logs
      if (shots && shots.length > 0) {
        updateShotLog();
      } else {
        shotsLogDiv.innerHTML = "";
      }
      
      // Set up board image loading
      boardImage.onload = drawAll;
      
      // Draw the board
      drawAll();
      updateUndoRedoState();
    }
    init();

    // Helper function to draw a dart with specific opacity
    function drawDartAtOpacity(shot, opacity) {
      // Draw dashed line between aim and hit
      if (shot.aim && shot.hit) {
        ctx.save();
        ctx.setLineDash([4,4]);
        ctx.beginPath();
        ctx.moveTo(shot.aim.x, shot.aim.y);
        ctx.lineTo(shot.hit.x, shot.hit.y);
        ctx.strokeStyle = `rgba(128, 128, 128, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
      
      // Draw hit marker as an X with opacity
      if (shot.hit) {
        const hx = shot.hit.x, hy = shot.hit.y;
        // Draw a thin black outline
        ctx.save();
        ctx.strokeStyle = `rgba(0, 0, 0, ${opacity})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(hx - 4, hy - 4);
        ctx.lineTo(hx + 4, hy + 4);
        ctx.moveTo(hx + 4, hy - 4);
        ctx.lineTo(hx - 4, hy + 4);
        ctx.stroke();
        ctx.restore();
        
        // Draw the white X on top
        ctx.save();
        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(hx - 4, hy - 4);
        ctx.lineTo(hx + 4, hy + 4);
        ctx.moveTo(hx + 4, hy - 4);
        ctx.lineTo(hx - 4, hy + 4);
        ctx.stroke();
        ctx.restore();
      }
    }

    // Function to update the animation state of fading darts
    function updateFadingDarts() {
      const now = performance.now();
      let needsRedraw = false;
      
      // Update each fading dart's opacity based on animation progress
      fadingDarts = fadingDarts.filter(fadingDart => {
        const elapsed = now - fadingDart.startTime;
        
        // Remove completed animations
        if (elapsed >= ANIMATION_DURATION) {
          return false;
        }
        
        // Calculate progress (0 to 1) with a smooth easing function
        const progress = elapsed / ANIMATION_DURATION;
        const easedProgress = 0.5 - Math.cos(progress * Math.PI) / 2; // Smooth easing
        
        // Update opacity based on animation type
        if (fadingDart.type === 'fadeOut') {
          // Fading out completely (from reduced opacity to 0)
          fadingDart.opacity = fadingDart.startOpacity * (1 - easedProgress);
        } else if (fadingDart.type === 'fadeDown') {
          // Fading from full opacity to reduced opacity
          fadingDart.opacity = fadingDart.startOpacity - 
            (fadingDart.startOpacity - REDUCED_OPACITY) * easedProgress;
        }
        
        needsRedraw = true;
        return true;
      });
      
      // If any darts are still animating, request another frame and redraw
      if (needsRedraw) {
        drawAll();
        requestAnimationFrame(updateFadingDarts);
      }
      
      // Update shot count for next comparison
      lastShotCount = shots.length;
    }

    // Function to detect darts that need animations
    function checkForFadingDarts() {
      // Get current turn information
      const currentTurnDartCount = shots.length % 3 || 3; // 1-3 darts in current turn
      
      // Clear existing animations for better control
      fadingDarts = [];
      
      // Starting a new turn after completing the previous one
      // This happens when adding the 4th, 7th, 10th dart etc.
      const startingNewTurnAfterComplete = shots.length % 3 === 1 && shots.length > 3;
      
      // Starting a new turn after an incomplete one
      // This happens when adding the 4th, 7th, 10th dart but the previous turn wasn't complete
      const startingNewTurn = shots.length % 3 === 1 && shots.length > 3;
      
      // The display limit (current turn + 12 more darts)
      const displayLimit = currentTurnDartCount + 12;
      
      // For all shots, determine which need animations
      for (let i = 0; i < shots.length; i++) {
        const reversedIdx = shots.length - 1 - i;
        
        // 1. Handle the transition from full to reduced opacity
        // When we add the first dart of a new turn (4th, 7th, etc.), 
        // the previous complete turn's darts (1-3, 4-6, etc.) should fade down
        if (startingNewTurn && 
            reversedIdx >= currentTurnDartCount && 
            reversedIdx < currentTurnDartCount + 3) {
          fadingDarts.push({
            dartIndex: i,
            type: 'fadeDown',
            startOpacity: FULL_OPACITY,
            opacity: FULL_OPACITY,
            startTime: performance.now()
          });
        }
        
        // 2. Handle darts that need to fade out completely
        // When we start a new turn and push older darts beyond the display limit
        if (startingNewTurn && 
            reversedIdx >= displayLimit && 
            reversedIdx < displayLimit + 3) {
          fadingDarts.push({
            dartIndex: i,
            type: 'fadeOut',
            startOpacity: REDUCED_OPACITY,
            opacity: REDUCED_OPACITY,
            startTime: performance.now()
          });
        }
      }
      
      // If we have animations to process, start the animation loop
      if (fadingDarts.length > 0) {
        requestAnimationFrame(updateFadingDarts);
      }
      
      // Update shot count for next comparison
      lastShotCount = shots.length;
    }

    // Magnifier functionality
    function updateMagnifier(mouseX, mouseY, isMouseDown = false) {
      const magnifier = document.getElementById("magnifier");
      const magnifierCanvas = document.getElementById("magnifierCanvas");
      const magnifierCtx = magnifierCanvas.getContext("2d");
      
      // Set magnification level
      const zoomFactor = 2;
      
      // Position the magnifier depending on mouse state
      let magX, magY;
      
      if (isMouseDown) {
        // When mouse is down, position directly at cursor (centered)
        magX = mouseX - magnifier.offsetWidth / 2;
        magY = mouseY - magnifier.offsetHeight / 2;
      } else {
        // When mouse is up, use original offset positioning
        const offsetX = 20;
        const offsetY = 20;
        magX = mouseX + offsetX;
        magY = mouseY + offsetY;
        
        // Keep magnifier within canvas boundaries
        if (magX + magnifier.offsetWidth > canvas.width) {
          magX = mouseX - offsetX - magnifier.offsetWidth;
        }
        if (magY + magnifier.offsetHeight > canvas.height) {
          magY = mouseY - offsetY - magnifier.offsetHeight;
        }
      }
      
      // Update magnifier position
      magnifier.style.left = magX + 'px';
      magnifier.style.top = magY + 'px';
      magnifier.style.display = "block";
      
      // Clear previous content
      magnifierCtx.clearRect(0, 0, magnifierCanvas.width, magnifierCanvas.height);
      
      // Calculate source area for zooming
      const sourceSize = magnifierCanvas.width / zoomFactor;
      const sourceX = mouseX - sourceSize / 2;
      const sourceY = mouseY - sourceSize / 2;
      
      // Draw the zoomed portion of the canvas
      magnifierCtx.drawImage(
        canvas,
        sourceX, sourceY, sourceSize, sourceSize,
        0, 0, magnifierCanvas.width, magnifierCanvas.height
      );
      
      // Add crosshair for precision
      magnifierCtx.strokeStyle = "rgba(255, 255, 255, 0.85)";
      magnifierCtx.lineWidth = 1;
      
      // Horizontal line
      magnifierCtx.beginPath();
      magnifierCtx.moveTo(0, magnifierCanvas.height / 2);
      magnifierCtx.lineTo(magnifierCanvas.width, magnifierCanvas.height / 2);
      magnifierCtx.stroke();
      
      // Vertical line
      magnifierCtx.beginPath();
      magnifierCtx.moveTo(magnifierCanvas.width / 2, 0);
      magnifierCtx.lineTo(magnifierCanvas.width / 2, magnifierCanvas.height);
      magnifierCtx.stroke();
    }

    let isMouseDown = false;
    canvas.addEventListener("mousedown", function(e) {
      isMouseDown = true;
    });
    canvas.addEventListener("mouseup", function(e) {
      isMouseDown = false;
    });
    canvas.addEventListener("mousemove", function(e) {
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      updateMagnifier(x, y, isMouseDown);
    });

    canvas.addEventListener("mouseout", function() {
      const magnifier = document.getElementById("magnifier");
      magnifier.style.display = "none";
    });
    
    /*****************************************
     *       ACCURACY STATISTICS FUNCTIONS
     *****************************************/
    // Get deviation map canvas and context
    const deviationCanvas = document.getElementById("deviationMap");
    const deviationCtx = deviationCanvas.getContext("2d");
    
    // Constants for the deviation map
    const DEV_MAP_CENTER_X = deviationCanvas.width / 2;
    const DEV_MAP_CENTER_Y = deviationCanvas.height / 2;
    const DEFAULT_MAX_CM = 5; // Default max cm when no shots exist
    const RECENT_THROW_COLOR = "#3498db"; // Blue for recent throws
    const OLDER_THROW_COLOR = "#95a5a6"; // Gray for older throws
    const CROSSHAIR_COLOR = "#e74c3c"; // Red for the crosshair
    
    // Dynamic grid settings (will be calculated)
    let maxDisplayCm = DEFAULT_MAX_CM; // Maximum cm to show on the grid (will be updated dynamically)
    let devGridSize = deviationCanvas.width / (2 * DEFAULT_MAX_CM); // Pixels per cm (will be updated)
    
    // Calculate average deviation to determine scale
    function calculateAverageDeviation() {
      if (shots.length === 0) return DEFAULT_MAX_CM;
      
      // Get deviations for all shots
      const deviations = shots.map(calculateDeviation).filter(dev => dev !== null);
      if (deviations.length === 0) return DEFAULT_MAX_CM;
      
      // Calculate average deviation
      const avgDev = deviations.reduce((sum, dev) => sum + dev.total, 0) / deviations.length;
      
      // Return twice the average (with a minimum to avoid tiny scale)
      return Math.max(avgDev * 2, 2); // Minimum 2cm scale
    }
    
    // Update the grid size based on the max display cm
    function updateGridSize() {
      // Update the max display cm based on average deviation (2x average)
      maxDisplayCm = calculateAverageDeviation();
      
      // Calculate grid size in pixels per cm
      // We divide half the canvas width by the max cm to get pixels per cm
      devGridSize = (deviationCanvas.width / 2) / maxDisplayCm;
    }
    
    // Draw the deviation map grid and crosshair
    function drawDeviationMapBase() {
      // Update grid settings based on shot data
      updateGridSize();
      
      // Clear the canvas
      deviationCtx.clearRect(0, 0, deviationCanvas.width, deviationCanvas.height);
      
      // Set background color
      deviationCtx.fillStyle = "#f8f9fa";
      deviationCtx.fillRect(0, 0, deviationCanvas.width, deviationCanvas.height);
      
      // Draw grid
      deviationCtx.strokeStyle = "#ddd";
      deviationCtx.lineWidth = 1;
      
      // Calculate grid interval (make sure we don't draw too many lines)
      let gridInterval = 1; // cm per grid line
      if (maxDisplayCm > 10) gridInterval = 2;
      if (maxDisplayCm > 20) gridInterval = 5;
      if (maxDisplayCm > 50) gridInterval = 10;
      
      // Vertical grid lines
      for (let cm = gridInterval; cm <= maxDisplayCm; cm += gridInterval) {
        // Right of center
        const xRight = DEV_MAP_CENTER_X + (cm * devGridSize);
        deviationCtx.beginPath();
        deviationCtx.moveTo(xRight, 0);
        deviationCtx.lineTo(xRight, deviationCanvas.height);
        deviationCtx.stroke();
        
        // Left of center
        const xLeft = DEV_MAP_CENTER_X - (cm * devGridSize);
        deviationCtx.beginPath();
        deviationCtx.moveTo(xLeft, 0);
        deviationCtx.lineTo(xLeft, deviationCanvas.height);
        deviationCtx.stroke();
      }
      
      // Horizontal grid lines
      for (let cm = gridInterval; cm <= maxDisplayCm; cm += gridInterval) {
        // Below center
        const yBelow = DEV_MAP_CENTER_Y + (cm * devGridSize);
        deviationCtx.beginPath();
        deviationCtx.moveTo(0, yBelow);
        deviationCtx.lineTo(deviationCanvas.width, yBelow);
        deviationCtx.stroke();
        
        // Above center
        const yAbove = DEV_MAP_CENTER_Y - (cm * devGridSize);
        deviationCtx.beginPath();
        deviationCtx.moveTo(0, yAbove);
        deviationCtx.lineTo(deviationCanvas.width, yAbove);
        deviationCtx.stroke();
      }
      
      // Draw axes with slightly darker lines
      deviationCtx.strokeStyle = "#aaa";
      deviationCtx.lineWidth = 1.5;
      
      // Horizontal axis
      deviationCtx.beginPath();
      deviationCtx.moveTo(0, DEV_MAP_CENTER_Y);
      deviationCtx.lineTo(deviationCanvas.width, DEV_MAP_CENTER_Y);
      deviationCtx.stroke();
      
      // Vertical axis
      deviationCtx.beginPath();
      deviationCtx.moveTo(DEV_MAP_CENTER_X, 0);
      deviationCtx.lineTo(DEV_MAP_CENTER_X, deviationCanvas.height);
      deviationCtx.stroke();
      
      // Draw the center crosshair
      deviationCtx.strokeStyle = CROSSHAIR_COLOR;
      deviationCtx.lineWidth = 2;
      
      // Horizontal line of crosshair
      deviationCtx.beginPath();
      deviationCtx.moveTo(DEV_MAP_CENTER_X - 10, DEV_MAP_CENTER_Y);
      deviationCtx.lineTo(DEV_MAP_CENTER_X + 10, DEV_MAP_CENTER_Y);
      deviationCtx.stroke();
      
      // Vertical line of crosshair
      deviationCtx.beginPath();
      deviationCtx.moveTo(DEV_MAP_CENTER_X, DEV_MAP_CENTER_Y - 10);
      deviationCtx.lineTo(DEV_MAP_CENTER_X, DEV_MAP_CENTER_Y + 10);
      deviationCtx.stroke();
      
      // Label the axes with cm indicators
      deviationCtx.fillStyle = "#555";
      deviationCtx.font = "10px Arial";
      deviationCtx.textAlign = "center";
      
      // X-axis labels (cm) - use the same interval as the grid
      for (let cm = gridInterval; cm <= maxDisplayCm; cm += gridInterval) {
        // Positive direction
        deviationCtx.fillText(`${cm}`, DEV_MAP_CENTER_X + (cm * devGridSize), DEV_MAP_CENTER_Y + 15);
        // Negative direction
        deviationCtx.fillText(`-${cm}`, DEV_MAP_CENTER_X - (cm * devGridSize), DEV_MAP_CENTER_Y + 15);
      }
      
      // Y-axis labels (cm)
      deviationCtx.textAlign = "right";
      for (let cm = gridInterval; cm <= maxDisplayCm; cm += gridInterval) {
        // Positive direction (up is negative on canvas)
        deviationCtx.fillText(`-${cm}`, DEV_MAP_CENTER_X - 5, DEV_MAP_CENTER_Y - (cm * devGridSize) + 3);
        // Negative direction (down is positive on canvas)
        deviationCtx.fillText(`${cm}`, DEV_MAP_CENTER_X - 5, DEV_MAP_CENTER_Y + (cm * devGridSize) + 3);
      }
      
      // Add indication of current scale at the bottom
      deviationCtx.font = "9px Arial";
      deviationCtx.textAlign = "center";
      deviationCtx.fillText(`Scale: ±${maxDisplayCm.toFixed(1)} cm`, DEV_MAP_CENTER_X, deviationCanvas.height - 5);
    }
    
    // Calculate deviation between aim and hit point in cm
    function calculateDeviation(shot) {
      if (!shot.aim || !shot.hit) return null;
      
      // Calculate deviation in pixels
      const dx = shot.hit.x - shot.aim.x;
      const dy = shot.hit.y - shot.aim.y;
      
      // Convert to cm using the existing utility function
      const dxCm = pxToCM(Math.abs(dx));
      const dyCm = pxToCM(Math.abs(dy));
      
      // Return the deviation with sign (important for direction tendencies)
      return {
        x: dx > 0 ? dxCm : -dxCm, // Positive = right, negative = left
        y: dy > 0 ? dyCm : -dyCm, // Positive = down, negative = up (in board coordinates)
        total: pxToCM(Math.hypot(dx, dy)) // Total deviation distance
      };
    }
    
    // Draw a single deviation point on the map
    function drawDeviationPoint(deviation, isRecent = false) {
      if (!deviation) return;
      
      // Calculate position on the deviation map using the dynamic grid size
      // Note: y is inverted because canvas coordinates go down but we want "up" to be positive
      const x = DEV_MAP_CENTER_X + (deviation.x * devGridSize);
      const y = DEV_MAP_CENTER_Y + (deviation.y * devGridSize);
      
      // Check if point is outside the visible area
      if (x < 0 || x > deviationCanvas.width || y < 0 || y > deviationCanvas.height) {
        return; // Don't draw points outside the canvas
      }
      
      // Set color based on recency
      deviationCtx.fillStyle = isRecent ? RECENT_THROW_COLOR : OLDER_THROW_COLOR;
      
      // Draw the point
      deviationCtx.beginPath();
      deviationCtx.arc(x, y, 4, 0, 2 * Math.PI);
      deviationCtx.fill();
    }
    
    // Update the deviation map with all throws
    function updateDeviationMap() {
      // Draw the base map (grid and crosshair)
      drawDeviationMapBase();
      
      if (shots.length === 0) return;
      
      // Get deviations for all shots
      const deviations = shots.map(calculateDeviation).filter(dev => dev !== null);
      
      // Define recency threshold (last 3 darts are considered recent)
      const recentThreshold = Math.max(0, shots.length - 3);
      
      // Draw all deviation points
      deviations.forEach((dev, index) => {
        const isRecent = index >= recentThreshold;
        drawDeviationPoint(dev, isRecent);
      });
      
      // Update statistics
      updateDeviationStats(deviations);
    }
    
    // Calculate and display statistics
    function updateDeviationStats(deviations) {
      if (!deviations || deviations.length === 0) {
        document.getElementById('avgDeviation').textContent = '-';
        document.getElementById('maxDeviation').textContent = '-';
        document.getElementById('horizontalTendency').textContent = '-';
        document.getElementById('verticalTendency').textContent = '-';
        document.getElementById('totalThrows').textContent = '0';
        return;
      }
      
      // Total number of throws
      document.getElementById('totalThrows').textContent = deviations.length.toString();
      
      // Calculate average deviation (total distance)
      const avgDev = deviations.reduce((sum, dev) => sum + dev.total, 0) / deviations.length;
      document.getElementById('avgDeviation').textContent = `${avgDev.toFixed(1)} cm`;
      
      // Calculate maximum deviation
      const maxDev = Math.max(...deviations.map(dev => dev.total));
      document.getElementById('maxDeviation').textContent = `${maxDev.toFixed(1)} cm`;
      
      // Calculate horizontal tendency (average x deviation)
      const avgX = deviations.reduce((sum, dev) => sum + dev.x, 0) / deviations.length;
      const horizTrend = avgX.toFixed(1);
      const horizDir = avgX > 0 ? 'right' : avgX < 0 ? 'left' : 'center';
      document.getElementById('horizontalTendency').textContent = 
        avgX === 0 ? 'Centered' : `${Math.abs(horizTrend)} cm ${horizDir}`;
      
      // Calculate vertical tendency (average y deviation)
      const avgY = deviations.reduce((sum, dev) => sum + dev.y, 0) / deviations.length;
      const vertTrend = avgY.toFixed(1);
      const vertDir = avgY > 0 ? 'low' : avgY < 0 ? 'high' : 'center';
      document.getElementById('verticalTendency').textContent = 
        avgY === 0 ? 'Centered' : `${Math.abs(vertTrend)} cm ${vertDir}`;
    }
    
    // Function to integrate with existing code
    function updateAllStats() {
      updateDeviationMap();
    }
    
    // Initialize the deviation map on page load
    function initDeviationMap() {
      drawDeviationMapBase();
      if (shots.length > 0) {
        updateDeviationMap();
      }
    }
    
    // --- Modified functions to integrate with the new feature ---
    
    // Modify the existing drawAll function to also update stats
    const originalDrawAll = drawAll;
    drawAll = function() {
      originalDrawAll();
      updateAllStats();
    };
    
    // Modify clear shots button handler to also clear stats
    const originalClearBtn = document.getElementById("clearDataBtn").onclick;
    document.getElementById("clearDataBtn").onclick = function(e) {
      // The original function uses a confirm dialog so we leave it as is
      // It will eventually call drawAll which will update our stats
    };
    
    // Initialize the deviation map when everything else is initialized
    const originalInit = init;
    init = function() {
      originalInit();
      initDeviationMap();
    };
    
    // Add init for deviations map to load event
    window.addEventListener('load', initDeviationMap);
    
    init();
  </script>
</body>
</html>
