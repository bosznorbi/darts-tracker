<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Darts Tracker – Two Calibration Modes with Aiming</title>
  <!-- Add Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body { font-family: Arial, sans-serif; text-align: center; }
    canvas { 
      border: 1px solid #000; 
      margin-top: 10px; 
      position: relative;
    }
    button { margin: 5px; padding: 5px 10px; }
    #calibrationInstructions { margin-top: 10px; font-weight: bold; }
    #shotsLog {
      margin-top: 10px;
      width: 600px;
      margin: 0 auto;
      text-align: left;
      font-size: 14px;
      line-height: 1.4em;
    }
    
    /* Canvas container for positioning the icons */
    #canvasContainer {
      position: relative;
      width: 600px;
      height: 600px;
      margin: 0 auto;
    }
    
    /* Icon button styling */
    .icon-button {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.2s;
      z-index: 10;
      border: none;
    }
    .icon-button:hover {
      background: rgba(255, 255, 255, 1);
      transform: scale(1.1);
      box-shadow: 0 3px 7px rgba(0,0,0,0.3);
    }
    .icon-button:active {
      transform: scale(0.95);
    }
    .icon-button i {
      font-size: 20px;
      color: #333;
    }
    .icon-tooltip {
      position: absolute;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
      white-space: nowrap;
    }
    .icon-button:hover .icon-tooltip {
      opacity: 1;
    }
    
    /* Positioning tooltips based on button location */
    #importDataBtn .icon-tooltip, #exportDataBtn .icon-tooltip {
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 5px;
    }
    
    #clearDataBtn .icon-tooltip {
      top: 100%;
      right: 0;
      margin-top: 5px;
    }
    
    #uploadPhotoBtn .icon-tooltip {
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 5px;
    }
    
    #quickCalibBtn .icon-tooltip, #fullCalibBtn .icon-tooltip {
      bottom: 100%;
      right: 0;
      margin-bottom: 5px;
    }
    
    /* Positioning as requested */
    #importDataBtn { top: 10px; left: 10px; }
    #exportDataBtn { top: 10px; left: 60px; }
    #clearDataBtn { top: 10px; right: 10px; }
    #uploadPhotoBtn { bottom: 10px; left: 10px; }
    #quickCalibBtn { bottom: 10px; right: 10px; }
    #fullCalibBtn { bottom: 10px; right: 60px; }
    
    /* Custom notification */
    #notification {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 100;
      text-align: center;
      max-width: 80%;
    }
    
    /* Custom confirmation dialog */
    #confirmDialog {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
      text-align: center;
      min-width: 250px;
    }
    #confirmMessage {
      margin-bottom: 15px;
      font-size: 16px;
    }
    .dialog-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .dialog-button {
      padding: 8px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background 0.2s;
    }
    #confirmCancel {
      background: #f0f0f0;
      color: #333;
    }
    #confirmOk {
      background: #007bff;
      color: white;
    }
    #confirmCancel:hover {
      background: #e0e0e0;
    }
    #confirmOk:hover {
      background: #0069d9;
    }
  </style>
</head>
<body>
  <h1>Darts Accuracy Tracker</h1>
  <div id="canvasContainer">
    <canvas id="dartboard" width="600" height="600"></canvas>
    <button id="importDataBtn" class="icon-button" title="Import Data">
      <i class="fas fa-file-import"></i>
      <span class="icon-tooltip">Import Data</span>
    </button>
    <button id="exportDataBtn" class="icon-button" title="Export Data">
      <i class="fas fa-file-export"></i>
      <span class="icon-tooltip">Export Data</span>
    </button>
    <button id="clearDataBtn" class="icon-button" title="Clear Shots">
      <i class="fas fa-trash-alt"></i>
      <span class="icon-tooltip">Clear Shots</span>
    </button>
    <button id="uploadPhotoBtn" class="icon-button" title="Upload Photo">
      <i class="fas fa-image"></i>
      <span class="icon-tooltip">Upload Board Photo</span>
    </button>
    <button id="quickCalibBtn" class="icon-button" title="Quick Calibration">
      <i class="fas fa-bolt"></i>
      <span class="icon-tooltip">Quick Calibration</span>
    </button>
    <button id="fullCalibBtn" class="icon-button" title="Full Calibration">
      <i class="fas fa-bullseye"></i>
      <span class="icon-tooltip">Full Calibration</span>
    </button>
  </div>
  <div id="calibrationInstructions"></div>
  <div id="shotsLog"></div>

  <!-- Hidden file inputs for .drts file and board photo -->
  <input type="file" id="fileInput" accept=".drts" style="display:none;" />
  <input type="file" id="photoInput" accept="image/*" style="display:none;" />

  <div id="notification"></div>
  <div id="confirmDialog">
    <div id="confirmMessage"></div>
    <div class="dialog-buttons">
      <button id="confirmCancel" class="dialog-button">Cancel</button>
      <button id="confirmOk" class="dialog-button">OK</button>
    </div>
  </div>

  <script>
    /*****************************************
     *       CONSTANTS & DEFAULTS
     *****************************************/
    const canvas = document.getElementById("dartboard");
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Default ring radii (in pixels) for a 600×600 board.
    let defaultBullseyeRadius   = 15;
    let defaultOuterBullRadius  = 30;
    let defaultTripleRingInner  = 120;
    let defaultTripleRingOuter  = 140;
    let defaultDoubleRingInner  = 240;
    let defaultDoubleRingOuter  = 260;

    // Official dartboard diameter in mm.
    const realBoardDiameterMM = 451;
    // For quick calibration, official ring distances (mm)
    const OFFICIAL_MM = {
      bullseye:   6.35,
      outerBull:  15.9,
      tripleIn:   99,
      tripleOut:  107,
      doubleIn:   162,
      doubleOut:  170
    };

    const sectorAngle = Math.PI / 10;  // 18° per sector.
    const sectorOrder = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];

    /*****************************************
     *        CALIBRATION DATA
     *****************************************/
    let calibration = {
      mode: "none", // "none", "full", or "quick"
      center: { x: centerX, y: centerY },
      bullseye: defaultBullseyeRadius,
      outerBull: defaultOuterBullRadius,
      tripleIn: defaultTripleRingInner,
      tripleOut: defaultTripleRingOuter,
      doubleIn: defaultDoubleRingInner,
      doubleOut: defaultDoubleRingOuter,
      rotation: -Math.PI / 20,
      photoDataUrl: null
    };

    /*****************************************
     *          SHOT DATA & AIM
     *****************************************/
    let shots = [];  // Each shot: { aim: {x,y}, hit: {x,y} }
    let currentAim = null;

    /*****************************************
     *       BOARD IMAGE & LOG
     *****************************************/
    const boardImage = new Image();
    boardImage.src = "board.png";
    const shotsLogDiv = document.getElementById("shotsLog");

    /*****************************************
     *        CALIBRATION STATE
     *****************************************/
    let isCalibrating = false;
    let calibrationStep = 0;  // For "full": 1..8, for "quick": 1..2.
    let calibMousePos = null;   // Live mouse position during calibration.

    /*****************************************
     *       LOAD & SAVE FUNCTIONS
     *****************************************/
    function loadShots() {
      const stored = localStorage.getItem("dartDataAll");
      if (stored) {
        let parsed = JSON.parse(stored);
        if (parsed.shots && Array.isArray(parsed.shots)) { shots = parsed.shots; }
        if (parsed.calibration) { calibration = parsed.calibration; applyCalibration(); }
      }
    }
    function saveShots() {
      let dataObj = { shots, calibration };
      localStorage.setItem("dartDataAll", JSON.stringify(dataObj));
    }

    /*****************************************
     *            CLEAR DATA
     *****************************************/
    // Clear only shot data (leaving calibration intact)
    document.getElementById("clearDataBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to clear all shots? Calibration will be retained.", function() {
        shots = [];
        shotsLogDiv.innerHTML = "";
        currentAim = null;
        saveShots();
        drawAll();
        showNotification("Shots cleared successfully");
      });
    });

    /*****************************************
     *           APPLY CALIBRATION
     *****************************************/
    function applyCalibration() {
      if (calibration.photoDataUrl) {
        let tmpImg = new Image();
        tmpImg.src = calibration.photoDataUrl;
        tmpImg.onload = function() {
          boardImage.src = tmpImg.src;
          drawAll();
        };
      }
      drawAll();
    }

    /*****************************************
     *         UTILITY FUNCTIONS
     *****************************************/
    // Convert pixels to centimeters based on the calibrated double ring.
    function pxToCM(pxDist) {
      let boardDiameterPX = calibration.doubleOut * 2;
      let mmPerPx = realBoardDiameterMM / boardDiameterPX;
      return (pxDist * mmPerPx) / 10;
    }

    /*****************************************
     *              SCORING
     *****************************************/
    function getDartScore(x, y) {
      const dx = x - calibration.center.x;
      const dy = y - calibration.center.y;
      const r = Math.hypot(dx, dy);
      if (r > calibration.doubleOut) return 0;
      if (r <= calibration.bullseye) return 50;
      if (r <= calibration.outerBull) return 25;
      let multiplier = 1;
      if (r >= calibration.tripleIn && r <= calibration.tripleOut) multiplier = 3;
      else if (r >= calibration.doubleIn && r <= calibration.doubleOut) multiplier = 2;
      let angle = Math.atan2(dy, dx);
      let normalized = (angle + Math.PI/2 - calibration.rotation + sectorAngle + 2*Math.PI) % (2*Math.PI);
      let sectorIndex = Math.floor(normalized / sectorAngle);
      let baseValue = sectorOrder[sectorIndex];
      return baseValue * multiplier;
    }

    /*****************************************
     *          DRAWING FUNCTIONS
     *****************************************/
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(boardImage, 0, 0, canvas.width, canvas.height);
      
      // Draw grid wiring: ring boundaries & radial lines.
      ctx.save();
      ctx.globalAlpha = 0.8;
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = "gray";
      let rings = [
        calibration.bullseye,
        calibration.outerBull,
        calibration.tripleIn,
        calibration.tripleOut,
        calibration.doubleIn,
        calibration.doubleOut
      ];
      rings.forEach(r => {
        ctx.beginPath();
        ctx.arc(calibration.center.x, calibration.center.y, r, 0, 2*Math.PI);
        ctx.stroke();
      });
      for (let i = 0; i < 20; i++) {
        let angle = calibration.rotation - Math.PI/2 + i * sectorAngle;
        let x1 = calibration.center.x + calibration.bullseye * Math.cos(angle);
        let y1 = calibration.center.y + calibration.bullseye * Math.sin(angle);
        let x2 = calibration.center.x + calibration.doubleOut * Math.cos(angle);
        let y2 = calibration.center.y + calibration.doubleOut * Math.sin(angle);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.restore();

      // In calibration mode, re-add custom cursor and preview.
      if (isCalibrating && calibMousePos) {
        ctx.save();
        // If in ring calibration steps (for full: steps 2–7, or for quick step 2), draw dashed preview circle.
        if (
          (calibration.mode==="full" && calibrationStep >= 2 && calibrationStep <= 7) ||
          (calibration.mode==="quick" && calibrationStep===2)
        ) {
          ctx.setLineDash([5, 5]);
          let rPrev = Math.hypot(calibMousePos.x - calibration.center.x, calibMousePos.y - calibration.center.y);
          ctx.beginPath();
          ctx.arc(calibration.center.x, calibration.center.y, rPrev, 0, 2*Math.PI);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        // For final rotation step (full step 8), draw dashed line.
        if (
          (calibration.mode==="full" && calibrationStep===8) ||
          (calibration.mode==="quick" && calibrationStep===2)
        ) {
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(calibration.center.x, calibration.center.y);
          ctx.lineTo(calibMousePos.x, calibMousePos.y);
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        // Draw the custom calibration cursor: a white circle with a plus (cross) inside.
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.arc(calibMousePos.x, calibMousePos.y, 5, 0, 2*Math.PI);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(calibMousePos.x - 3, calibMousePos.y);
        ctx.lineTo(calibMousePos.x + 3, calibMousePos.y);
        ctx.moveTo(calibMousePos.x, calibMousePos.y - 3);
        ctx.lineTo(calibMousePos.x, calibMousePos.y + 3);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();
      }
    }

    // Highlight the aimed field:
    // If aiming within bull (r ≤ outerBull), fill full circle; otherwise fill the annular sector.
    function highlightAimedField(aimPos) {
      if (!aimPos) return;
      const dx = aimPos.x - calibration.center.x;
      const dy = aimPos.y - calibration.center.y;
      const r = Math.hypot(dx, dy);
      if (r <= calibration.outerBull) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(calibration.center.x, calibration.center.y, calibration.outerBull, 0, 2*Math.PI);
        ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
        ctx.fill();
        ctx.restore();
        return;
      }
      let ringMin = 0, ringMax = 0;
      if (r <= calibration.tripleIn) {
        ringMin = calibration.outerBull;
        ringMax = calibration.tripleIn;
      } else if (r <= calibration.tripleOut) {
        ringMin = calibration.tripleIn;
        ringMax = calibration.tripleOut;
      } else if (r <= calibration.doubleIn) {
        ringMin = calibration.tripleOut;
        ringMax = calibration.doubleIn;
      } else if (r <= calibration.doubleOut) {
        ringMin = calibration.doubleIn;
        ringMax = calibration.doubleOut;
      } else { return; }
      let angle = Math.atan2(dy, dx);
      let normalized = (angle + Math.PI/2 - calibration.rotation + 2*Math.PI) % (2*Math.PI);
      let sectorIdx = Math.floor(normalized / sectorAngle);
      let sectorStart = sectorIdx * sectorAngle;
      let sectorEnd = sectorStart + sectorAngle;
      let startAngle = sectorStart - Math.PI/2 + calibration.rotation;
      let endAngle = sectorEnd - Math.PI/2 + calibration.rotation;
      ctx.save();
      ctx.beginPath();
      ctx.arc(calibration.center.x, calibration.center.y, ringMax, startAngle, endAngle, false);
      ctx.arc(calibration.center.x, calibration.center.y, ringMin, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 255, 0, 0.3)";
      ctx.fill();
      ctx.restore();
    }

    function drawShots() {
      highlightAimedField(currentAim);
      shots.forEach(shot => {
        // Draw dashed line between aim and hit.
        if (shot.aim && shot.hit) {
          ctx.save();
          ctx.setLineDash([4,4]);
          ctx.beginPath();
          ctx.moveTo(shot.aim.x, shot.aim.y);
          ctx.lineTo(shot.hit.x, shot.hit.y);
          ctx.strokeStyle = "gray";
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
        }
        // Draw hit marker as an X:
        if (shot.hit) {
          const hx = shot.hit.x, hy = shot.hit.y;
          // Draw a thin light-gray outline.
          ctx.save();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 3;
          ctx.beginPath();
            ctx.moveTo(hx - 4, hy - 4);
            ctx.lineTo(hx + 4, hy + 4);
            ctx.moveTo(hx + 4, hy - 4);
            ctx.lineTo(hx - 4, hy + 4);
          ctx.stroke();
          ctx.restore();
            // Draw the white X on top.
            ctx.save();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(hx - 4, hy - 4);
            ctx.lineTo(hx + 4, hy + 4);
            ctx.moveTo(hx + 4, hy - 4);
            ctx.lineTo(hx - 4, hy + 4);
            ctx.stroke();
            ctx.restore();
        }
      });
    }

    function drawAll() {
      if (!boardImage.complete) return;
      drawBoard();
      drawShots();
    }

    /*****************************************
     *        CALIBRATION HANDLERS
     *****************************************/
    function updateInstructions() {
      const instr = document.getElementById("calibrationInstructions");
      if (!isCalibrating) { instr.textContent = ""; return; }
      let msg = "";
      if (calibration.mode === "full") {
        switch (calibrationStep) {
          case 1: msg = "Full Step 1: Click board center."; break;
          case 2: msg = "Step 2: Click to set bullseye radius."; break;
          case 3: msg = "Step 3: Click to set outer bull radius."; break;
          case 4: msg = "Step 4: Click to set inner treble radius."; break;
          case 5: msg = "Step 5: Click to set outer treble radius."; break;
          case 6: msg = "Step 6: Click to set inner double radius."; break;
          case 7: msg = "Step 7: Click to set outer double radius."; break;
          case 8: msg = "Step 8: Click the crossing of 20 & 1 at the top double ring."; break;
        }
      } else if (calibration.mode === "quick") {
        if (calibrationStep === 1) msg = "Quick Step 1: Click board center.";
        else if (calibrationStep === 2) msg = "Step 2: Click the crossing of 20 & 1 at the top double ring.";
      }
      instr.textContent = msg;
    }

    function distFromCenter(pt) {
      return Math.hypot(pt.x - calibration.center.x, pt.y - calibration.center.y);
    }

    function handleFullCalibrationClick(pt) {
      switch (calibrationStep) {
        case 1: calibration.center = pt; break;
        case 2: calibration.bullseye = distFromCenter(pt); break;
        case 3: calibration.outerBull = distFromCenter(pt); break;
        case 4: calibration.tripleIn = distFromCenter(pt); break;
        case 5: calibration.tripleOut = distFromCenter(pt); break;
        case 6: calibration.doubleIn = distFromCenter(pt); break;
        case 7: calibration.doubleOut = distFromCenter(pt); break;
        case 8:
          let dx = pt.x - calibration.center.x;
          let dy = pt.y - calibration.center.y;
          let angle = Math.atan2(dy, dx);
          calibration.rotation = angle + Math.PI / 2;
          isCalibrating = false; calibrationStep = 0; calibMousePos = null;
          showNotification("Full calibration complete", 4000);
          break;
      }
      if (calibrationStep < 8) calibrationStep++;
      updateInstructions();
      drawAll();
      saveShots();
    }

    function handleQuickCalibrationClick(pt) {
      if (calibrationStep === 1) { calibration.center = pt; }
      else if (calibrationStep === 2) {
        let dx = pt.x - calibration.center.x;
        let dy = pt.y - calibration.center.y;
        let distPx = Math.hypot(dx, dy);
        let pxPerMm = distPx / OFFICIAL_MM.doubleOut;
        calibration.bullseye = OFFICIAL_MM.bullseye * pxPerMm;
        calibration.outerBull = OFFICIAL_MM.outerBull * pxPerMm;
        calibration.tripleIn = OFFICIAL_MM.tripleIn * pxPerMm;
        calibration.tripleOut = OFFICIAL_MM.tripleOut * pxPerMm;
        calibration.doubleIn = OFFICIAL_MM.doubleIn * pxPerMm;
        calibration.doubleOut = OFFICIAL_MM.doubleOut * pxPerMm;
        let angle = Math.atan2(dy, dx);
        calibration.rotation = angle + Math.PI / 2;
        isCalibrating = false; calibrationStep = 0; calibMousePos = null;
        showNotification("Quick calibration complete", 4000);
      }
      if (calibrationStep < 2) calibrationStep++;
      updateInstructions();
      drawAll();
      saveShots();
    }

    canvas.addEventListener("mousemove", function(e) {
      if (!isCalibrating) return;
      let rect = canvas.getBoundingClientRect();
      calibMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      drawAll();
    });

    canvas.addEventListener("click", function(e) {
      let rect = canvas.getBoundingClientRect();
      let clickPt = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      if (isCalibrating) {
        if (calibration.mode === "full") {
          handleFullCalibrationClick(clickPt);
        } else if (calibration.mode === "quick") {
          handleQuickCalibrationClick(clickPt);
        }
      } else {
        if (!currentAim) {
          showNotification("Right-click first to set your aim");
          return;
        }
        let hitPt = { x: clickPt.x, y: clickPt.y };
        shots.push({ aim: currentAim, hit: hitPt });
        saveShots();
        let dx = hitPt.x - currentAim.x;
        let dy = hitPt.y - currentAim.y;
        let distCm = Math.hypot(pxToCM(dx), pxToCM(dy));
        let score = getDartScore(hitPt.x, hitPt.y);
        shotsLogDiv.innerHTML += `Shot #${shots.length}: Score=${score}, Distance=${distCm.toFixed(2)} cm<br/>`;
        drawAll();
      }
    });

    // --- Right-Click Aiming Mechanism ---
    canvas.addEventListener("contextmenu", function(e) {
      e.preventDefault();
      if (isCalibrating) return;  // Do not set aim during calibration.
      let rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      let pos = getSnappedPosition(x, y);
      if (!pos) {
        showNotification("Aim must be within the board");
        return;
      }
      currentAim = pos;
      drawAll();
    });

    function getSnappedPosition(px, py) {
      let dx = px - calibration.center.x;
      let dy = py - calibration.center.y;
      let r = Math.hypot(dx, dy);
      // For bull area, if within outerBull, snap aim to board center.
      if (r <= calibration.outerBull) {
        return { x: calibration.center.x, y: calibration.center.y };
      }
      let regionCenter = null;
      if (r <= calibration.tripleIn) {
        regionCenter = (calibration.outerBull + calibration.tripleIn) / 2;
      } else if (r <= calibration.tripleOut) {
        regionCenter = (calibration.tripleIn + calibration.tripleOut) / 2;
      } else if (r <= calibration.doubleIn) {
        regionCenter = (calibration.tripleOut + calibration.doubleIn) / 2;
      } else if (r <= calibration.doubleOut) {
        regionCenter = (calibration.doubleIn + calibration.doubleOut) / 2;
      } else { return null; }
      let theta = Math.atan2(dy, dx);
      let normalized = (theta + Math.PI/2 - calibration.rotation + 2*Math.PI) % (2*Math.PI);
      let sectorIdx = Math.floor(normalized / sectorAngle);
      let snappedAngle = (sectorIdx + 0.5) * sectorAngle - Math.PI/2 + calibration.rotation;
      return {
        x: calibration.center.x + regionCenter * Math.cos(snappedAngle),
        y: calibration.center.y + regionCenter * Math.sin(snappedAngle)
      };
    }

    /*****************************************
     *            BUTTON HANDLERS
     *****************************************/
    document.getElementById("exportDataBtn").addEventListener("click", function() {
      let dataObj = { shots, calibration };
      if (!calibration.photoDataUrl) {
        try {
          let tempCanvas = document.createElement("canvas");
          tempCanvas.width = boardImage.width;
          tempCanvas.height = boardImage.height;
          let tmpCtx = tempCanvas.getContext("2d");
          tmpCtx.drawImage(boardImage, 0, 0);
          calibration.photoDataUrl = tempCanvas.toDataURL("image/png");
        } catch(e) { console.warn("Could not encode board image:", e); }
      }
      dataObj.calibration = calibration;
      let dataStr = JSON.stringify(dataObj);
      let blob = new Blob([dataStr], { type: "text/plain" });
      let url = URL.createObjectURL(blob);
      let a = document.createElement("a");
      a.href = url;
      a.download = "dartdata.drts";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });

    document.getElementById("importDataBtn").addEventListener("click", function() {
      document.getElementById("fileInput").click();
    });
    document.getElementById("fileInput").addEventListener("change", function(e) {
      let file = e.target.files[0];
      if (!file) return;
      if (!file.name.endsWith(".drts")) {
        showNotification("Please select a .drts file");
        return;
      }
      let reader = new FileReader();
      reader.onload = function(event) {
        try {
          let imported = JSON.parse(event.target.result);
          if (!imported.shots || !imported.calibration) {
            showNotification("Invalid file format");
            return;
          }
          shots = imported.shots;
          calibration = imported.calibration;
          applyCalibration();
          saveShots();
          shotsLogDiv.innerHTML = "";
          drawAll();
          showNotification("Imported shots and calibration");
        } catch(err) {
          showNotification("Error reading file: " + err);
        }
      };
      reader.readAsText(file);
    });

    document.getElementById("uploadPhotoBtn").addEventListener("click", function() {
      document.getElementById("photoInput").click();
    });
    document.getElementById("photoInput").addEventListener("change", function(e) {
      let file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = function(evt) {
        calibration.photoDataUrl = evt.target.result;
        boardImage.src = evt.target.result;
        boardImage.onload = drawAll;
        saveShots();
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("fullCalibBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to re-calibrate?", function() {
        calibration.mode = "full";
        isCalibrating = true;
        calibrationStep = 1;
        calibMousePos = null;
        showNotification("Full calibration started - follow on-screen instructions", 5000);
        updateInstructions();
        drawAll();
      });
    });

    document.getElementById("quickCalibBtn").addEventListener("click", function() {
      showConfirmDialog("Are you sure you want to re-calibrate?", function() {
        calibration.mode = "quick";
        isCalibrating = true;
        calibrationStep = 1;
        calibMousePos = null;
        showNotification("Quick calibration started - follow on-screen instructions", 5000);
        updateInstructions();
        drawAll();
      });
    });

    /*****************************************
     *            NOTIFICATION SYSTEM
     *****************************************/
    function showNotification(message, duration = 3000) {
      const notification = document.getElementById("notification");
      notification.textContent = message;
      notification.style.opacity = 1;
      
      // Automatically hide the notification after the specified duration
      setTimeout(() => {
        notification.style.opacity = 0;
      }, duration);
    }

    function showConfirmDialog(message, onConfirm) {
      const dialog = document.getElementById("confirmDialog");
      const messageEl = document.getElementById("confirmMessage");
      const okButton = document.getElementById("confirmOk");
      const cancelButton = document.getElementById("confirmCancel");
      
      messageEl.textContent = message;
      dialog.style.display = "block";
      
      // Set up the button handlers
      okButton.onclick = function() {
        dialog.style.display = "none";
        onConfirm();
      };
      
      cancelButton.onclick = function() {
        dialog.style.display = "none";
      };
    }

    /*****************************************
     *              INIT
     *****************************************/
    function init() {
      loadShots();
      boardImage.onload = drawAll;
      drawAll();
    }
    init();
  </script>
</body>
</html>
